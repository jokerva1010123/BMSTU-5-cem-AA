\chapter{Исследовательская часть}

В данном разделе приводятся результаты замеров затрат реализаций алгоритмов по пиковой памяти и процессорному времени.

\section{Технические характеристики}

Технические характеристики устройства, на котором выполнялись замеры:

\begin{itemize}
	\item[---] Операционная система Window 10 Home Single Language;
	\item[---] Память 8 Гб;
	\item[---] Процессор 11th Gen Intel(R) Core(TM) i5-1135G7 2.42 ГГц, 4 ядра.
\end{itemize}

Во время замера устройство было подключено к сети электропитания, нагружено приложениями окружения и самой системой замера.

\section{Время выполнения реализаций алгоритмов}

Процессорное время реализаций алгоритмов замерялось при помощи функции process\_time() из библиотеки time языка Python. Данная функция возвращает количество секунд, прошедших с начала эпохи, типа float.

Контрольная точка возвращаемого значения не определна, поэтому допустима только разница между результатами последовательных вызовов.

Замеры времени для каждой длины слов проводились 300 раз. В качестве результата взято среднее время работы алгоритма на данной длине слова. При каждом запуске алгоритма, на вход подавались случайно сгенерированные строки, днины строк (Length) совпадаютю.

Результаты замеров приведены на рисунке \ref{img:time} (в микросекундах).

\img{75mm}{time}{Результаты замеров времени (в микросекундах)}
\newpage
На рис. 1.1 приняты следующие обозначения алгоритмов:
\begin{itemize}
    \item[---] Levenshtein --- нерекурсивный алгоритм нахождения расстояния \\Левенштейна,
    \item[---] Lev Domerau --- нерекурсивный алгоритм нахождения расстояния \\Дамерау-Левенштейна,
    \item[---] Recursive --- рекурсивный алгоритм нахождения расстояния Дамерау-Левенштейна,
    \item[---] Cache --- рекурсивный алгоритм нахождения расстояния Дамерау-Левенштейна с использованием кеша.
\end{itemize}

\section*{Вывод}

В результате замеров можно прийти к выводу, что матричная реализация алгоритмов нахождения расстояний заметно выигрывает по времени при росте строк.

\section{Затраты памяти выполнения реализаций алгоритмов}

Алгоритмы нахождения расстояний Левенштейна и Дамерау --- Левенштейна не отличаются друг от друга с точки зрения использования памяти, поэтому достаточно рассмотреть лишь разницу рекурсивной и матричной реализаций данных алгоритмов.

Пусть длина строки S1 --- n, длина строки S2 --- m, тогда затраты памяти на приведенные  алгоритмы будут следующими.

Матричный алгоритм поиска расстояния Левенштейна:
\begin{itemize}
    \item[---] строки S1, S2 --- (m + n) $\cdot$ sizeof(char),
    \item[---] матрица --- ((m + 1) $\cdot$ (n + 1)) $\cdot$ sizeof(int),
    \item[---] текущая строка матрицы --- (n + 1) $\cdot$ sizeof(int),
    \item[---] длины строк --- 2 $\cdot$ sizeof(int),
    \item[---] вспомогательные переменные ---  3 $\cdot$ sizeof(int).
\end{itemize}

Максимальная глубина стека вызовов при рекурсивной реализации равна сумме длин входящих строк.

Рекурсивный алгоритм поиска расстояния Дамерау -- Левенштейна (для каждого вызова):
\begin{itemize}
    \item[---] строки S1, S2 --- (m + n) $\cdot$ sizeof(char),
    \item[---] длины строк --- 2 $\cdot$ sizeof(int),
    \item[---] вспомогательные переменные ---  2 $\cdot$ sizeof(int),
    \item[---] размер аргументов функции --- 2 $\cdot$ 24,
    \item[---] размер адреса возврата --- 4.
\end{itemize}

Максимальная глубина стека вызовов при рекурсивной реализации равна сумме длин входящих строк. Таким образом, общая затраченная память в рекурсивном алгоритме будет равна $m + n + (2 \cdot 4 + 2 \cdot 4 + 4 + 2 \cdot 24) \cdot (n + m) = 85\cdot m + 85\cdot n$.

Рекурсивный алгоритм поиска расстояния Дамерау -- Левенштейна с использованием кеша (для каждого вызова): 

\begin{itemize}
    \item[---] Для всех вызовов память для хранения самой матрицы ---  ((m + 1) $\cdot$ (n + 1)) $\cdot$ sizeof(int),
    \item[---] строки S1, S2 --- (m + n) $\cdot$ sizeof(char),
    \item[---] длины строк --- 2 $\cdot$ sizeof(int),
    \item[---] вспомогательные переменные ---  1 $\cdot$ sizeof(int),
    \item[---] размер аргументов функции --- 2 $\cdot$ 24,
    \item[---] ссылка на матрицу --- 8 байт,
    \item[---] размер адреса возврата --- 4.
\end{itemize}
	
Максимальная глубина стека вызовов при рекурсивной реализации равна сумме длин входящих строк. Таким образом, общая затраченная память в рекурсивном алгоритме будет равна $m + n + 4 \cdot (m + 1) \cdot (n + 1) + (2 \cdot 4 + 4 + 4 + 2 \cdot 24) \cdot (n + m) = 4\cdot m\cdot n + 69\cdot m + 69\cdot n + 4$.

Матричный алгоритм поиска расстояния Дамерау -- Левенштейна: 
\begin{itemize}
    \item[---] строки S1, S2 --- (m + n) $\cdot$ sizeof(char),
    \item[---] матрица --- ((m + 1) $\cdot$ (n + 1)) $\cdot$ sizeof(int),
    \item[---] длины строк --- 2 $\cdot$ sizeof(int),
    \item[---] вспомогательные переменные --- 3 $\cdot$ sizeof(int).
\end{itemize}

Таким образом, общая затраченная память в рекурсивном алгоритме будет равна $m + n + 4 \cdot (m + 1) \cdot (n + 1) + 6 \cdot 4 = 4\cdot m\cdot n + 5\cdot m + 5\cdot n + 28$.

Результаты замеров приведены на рисунке \ref{img:memory}.

\img{75mm}{memory}{Результаты замеров памяти}

\section*{Вывод}

В результате можно прийти к выводу, что матричная реализация алгоритмов нахождения расстояний заметно выигрывает по памяти при росте строк.