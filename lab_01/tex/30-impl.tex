\chapter{Технологическая часть}

В данном разделе будут приведены требования к программному обеспечению, средства реализации и листинги кода.

\section{Требования к ПО}

Программа принимает две строки (регистрозависимые). В качестве результата возвращается число, равное редакторскому расстоянию. Необходимо реализовать возможность подсчета процессорного времени и пиковой использованной памяти для каждого из алго­ритмов.

\section{Средства реализации}

В качестве языка программирования для реализации данной лабораторной работы был выбран ЯП Python \cite{pythonlang}. 

Данный язык имеет все небходимые инструменты для решения поставленной задачи.

Процессорное время работы реализаций алгоритмов было замерено с помощью функции process\_time() из библиотеки time \cite{pythonlangtime}.

\section{Сведения о модулях программы}
Программа состоит из трех модулей:
\begin{enumerate}[label={\arabic*)}]
    \item main.py --- точка входа;
	\item algorythms.py --- хранит реализацию алгоритмов;
	\item compareTime.py --- хранит реализацию системы замера времени.
\end{enumerate}


\section{Листинг кода}

 В листингах \ref{lst:non_rec_l}, \ref{lst:non_rec_dl}, \ref{lst:rec_dl}, \ref{lst:rec_dl_cache} приведены реализаций алгоритмов нахождения расстояния Левенштейна и Дамерау--Левенштейна.

\begin{lstlisting}[label=lst:non_rec_l,caption=Функция нахождения расстояния Левенштейна нерекурсивным методом]
def levenshteinDistance(str1, str2, output = True):
    n = len(str1)
    m = len(str2)
    matrix = createMatrix(n + 1, m + 1)

    for i in range(1, n + 1):
        for j in range(1, m + 1):
            add = matrix[i - 1][j] + 1
            delete = matrix[i][j - 1] + 1
            change = matrix[i - 1][j - 1]

            if (str1[i - 1] != str2[j - 1]):
                change += 1

            matrix[i][j] = min(add, delete, change)

    if (output):
        printMatrix(matrix, str1, str2)

    return matrix[n][m]
	
\end{lstlisting}

\begin{lstlisting}[label=lst:non_rec_dl,caption=Функция нахождения расстояния Дамерау--Левенштейна нерекурсивным методом]
def damerauLevenshteinDistance(str1, str2, output = True):
    n = len(str1)
    m = len(str2)
    matrix = createMatrix(n + 1, m + 1)

    for i in range(1, n + 1):
        for j in range(1, m + 1):
            add = matrix[i - 1][j] + 1
            delete = matrix[i][j - 1] + 1
            change = matrix[i - 1][j - 1]
            if (str1[i - 1] != str2[j - 1]):
                change += 1
            swap = n
            if (i > 1 and j > 1 and
                str1[i - 1] == str2[j - 2] and
                str1[i - 2] == str2[j - 1]):
                    swap = matrix[i - 2][j - 2] + 1

            matrix[i][j] = min(add, delete, change, swap)

    if (output):
        printMatrix(matrix, str1, str2)

    return matrix[n][m]
	
\end{lstlisting}

\begin{lstlisting}[label=lst:rec_dl,caption=Функция нахождения расстояния Дамерау--Левенштейна с использованием рекурсии]
def damerauLevenshteinDistanceRecursive(str1, str2, output = True):
    n = len(str1)
    m = len(str2)
    flag = 0
    if ((n == 0) or (m == 0)):
        return abs(n - m)
    if (str1[-1] != str2[-1]):
        flag = 1
    minDistance = min(
        damerauLevenshteinDistanceRecursive(str1[:-1], str2) + 1,
        damerauLevenshteinDistanceRecursive(str1, str2[:-1]) + 1,
        damerauLevenshteinDistanceRecursive(str1[:-1], str2[:-1]) + flag
    )
    if (n > 1 and m > 1 and str1[-1] == str2[-2] and str1[-2] == str2[-1]):
        minDistance = min(
            minDistance,
            damerauLevenshteinDistanceRecursive(str1[:-2], str2[:-2]) + 1
        )
    return minDistance
	
\end{lstlisting}

\begin{lstlisting}[label=lst:rec_dl_cache,caption=Функция нахождения расстояния Дамерау--Левенштейна рекурсивным методом с использованием кеша]
def recursiveWithCache(str1, str2, n, m, matrix):
    if (matrix[n][m] != -1):
        return matrix[n][m]
    if (n == 0):
        matrix[n][m] = m
        return matrix[n][m]
    if ((n > 0) and (m == 0)):
        matrix[n][m] = n
        return matrix[n][m]
    add = recursiveWithCache(str1, str2, n - 1, m, matrix) + 1
    delete = recursiveWithCache(str1, str2, n, m - 1, matrix) + 1
    change = recursiveWithCache(str1, str2, n - 1, m - 1, matrix)
    if (str1[n - 1] != str2[m - 1]):
        change += 1 # flag
    matrix[n][m] = min(add, delete, change)
    if (n > 1 and m > 1 and
        str1[n - 1] == str2[m - 2] and
        str1[n - 2] == str2[m - 1]):

        matrix[n][m] = min(
            matrix[n][m],
            recursiveWithCache(str1, str2, n - 2, m - 2, matrix) + 1
        )
    return matrix[n][m]

def damerauLevenshteinDistanceRecurciveCache(str1, str2, output = True):
    n = len(str1)
    m = len(str2)
    matrix = createMatrix(n + 1, m + 1)
    for i in range(n + 1):
        for j in range(m + 1):
            matrix[i][j] = -1
    recursiveWithCache(str1, str2, n, m, matrix)
    if (output):
        printMatrix(matrix, str1, str2)
    return matrix[n][m]
\end{lstlisting}

\section{Функциональные тесты}
В таблице \ref{tabular:functional_test} приведены функциональные тесты для алгоритмов вычисления расстояния Левенштейна (в таблице столбец подписан "Левенштейн") и Дамерау-Левенштейна (в таблице - "Дамерау-Л."). Все тесты пройдены успешно.


\begin{table}[h]
    \begin{center}
    \begin{threeparttable}
    \captionsetup{justification=raggedright,singlelinecheck=off}	\caption{\label{tabular:functional_test} Функциональные тесты}
		\begin{tabular}{|l|l|l|l|l|}
			\hline
			&  \multicolumn{2}{c|}{Входные данные}& \multicolumn{2}{c|}{Ожидаемый результат} \\
			\hline
			№&Строка 1&Строка 2&Левенштейн&Дамерау-Л. \\
			\hline
			1&"пустая строка"&"пустая строка"&0&0 \\
			\hline
			2&"пустая строка"&a&1&1 \\
			\hline
			3&b&"пустая строка"&1&1 \\
			\hline
			4&asdfv&"пустая строка"&5&5 \\
			\hline
			5&"пустая строка"&sdfvs&5&5 \\
			\hline
			8&lll&lll&0&0 \\
			\hline
			9&qwem&qwem&0&0 \\
			\hline
			10&aa&cg&2&2 \\
			\hline
			11&kot&sobaka&5&5 \\
			\hline
			12&stroka&sobaka&3&3 \\
			\hline
			13&kot&kod&1&1 \\
			\hline
			14&cat&caaat&2&2 \\
			\hline
			15&cat&catty&2&2 \\
			\hline
			16&cat&tac&2&2 \\
			\hline
			17&recur&norecur&2&2 \\
			\hline
			18&1234&2143&3&2 \\
			\hline
			19&mriak&mriakmriak&5&5 \\
			\hline
			20&aaaaa&aa&3&3 \\
			\hline
            21&abcdef&acbdef&2&1\\
            \hline
		\end{tabular}
	\end{threeparttable}
	\end{center}
\end{table}

\section*{Вывод}

Были разработаны и протестированы алгоритмы нахождения расстояния Левенштейна нерекурсивно, нахождения расстояния Дамерау -- Левенштейна нерекурсивно, рекурсивно, а также рекурсивно с кешированием.
