\chapter{Исследовательская часть}

В данном разделе приводятся результаты замеров затрат реализаций алгоритмов по процессорному времени.

\section{Технические характеристики}

Технические характеристики устройства, на котором выполнялось тестирование:

\begin{itemize}
	\item[---] Операционная система Window 10 Home Single Language;
	\item[---] Память 8 Гб;
	\item[---] Процессор 11th Gen Intel(R) Core(TM) i5-1135G7 2.42 ГГц, 4 ядра.
\end{itemize}

Во время замера устройство было подключено к сети электропитания, нагружено приложениями окружения и самой системой замера.

\section{Время выполнения реализаций алгоритмов}

Процессорное время реализаций алгоритмов замерялось при помощи функции process\_time() из библиотеки time языка Python. Данная функция возвращает количество секунд, прошедших с начала эпохи, типа float.

Контрольная точка возвращаемого значения не определна, поэтому допустима только разница между результатами последовательных вызовов.

Замеры времени для каждой длины массива проводились 1000 раз. В качестве результата взято среднее время работы алгоритма на данной длине массива. При каждом запуске алгоритма, на вход подавались случайно сгенерированные массивы. Тестовые пакеты создавались до начала замера времени.

Результаты замеров приведены на рисунках \ref{img:time1}, \ref{img:time2}, \ref{img:time3} (в микросекундах).

\img{50mm}{time1}{Результаты замеров времени для неотсортированного массива (в микросекундах)}
\img{50mm}{time2}{Результаты замеров времени для отсортированного массива (в микросекундах)}
\img{50mm}{time3}{Результаты замеров времени для отсортированного в обратном порядке массива (в микросекундах)}

\clearpage

\section*{Вывод}

Алгоритмы гномьей сортировки и сортировки вставками работает быстрее алгоритма сортировки бинарным деревом независимо от того, как расположены объекты в сортируемом массиве. Напротив, сортировка бинарным деревом проигрывает двум другим алгоритмам по времени, так как использует рекурсию.
