\chapter{Аналитическая часть}
В данном разделе описаны определение словаря как структуры данных, а также алгоритмы поиска по словарю.

\section{Словарь как структура данных}

Словарь (или ''\textit{ассоциативный массив}'') \cite{dict} - абстрактный тип данных (интерфейс к хранилищу данных), позволяющий хранить пары вида «(ключ, значение)» и поддерживающий операции добавления пары, а также поиска и удаления пары по ключу:
\begin{itemize}
	\item \texttt{INSERT(k, v)};
	\item \texttt{FIND(k)};
	\item \texttt{REMOVE(k)}.
\end{itemize}

В паре \texttt{(k, v)}: \texttt{v} называется значением, ассоциированным с ключом \texttt{k}. Где \texttt{k} —-- это ключ, a \texttt{v} —-- значение. Семантика и названия вышеупомянутых операций в разных реализациях ассоциативного массива могут отличаться.

Операция \texttt{ПОИСК(k)} возвращает значение, ассоциированное с заданным ключом, или некоторый специальный объект \texttt{НЕ\_НАЙДЕНО}, означающий, что значения, ассоциированного с заданным ключом, нет.

Ассоциативный массив с точки зрения интерфейса удобно рассматривать как обычный массив, в котором в качестве индексов можно использовать не только целые числа, но и значения других типов — например, строки.

В данной лабораторной работе в качестве ключа будет использоваться строка: название города, а в качестве значения -- число: население этого города.

\section{Алгоритм полного перебора}
Алгоритмом полного перебора \cite{AI} называют метод решения задачи, при котором по очереди рассматриваются все возможные варианты. В случае реализации алгоритма в рамках данной работы будут последовательно перебираться ключи словаря до тех пор, пока не будет найден нужный. 

Трудоёмкость алгоритма зависит от того, присутствует ли искомый ключ в словаре, и, если присутствует -- насколько он далеко от начала массива ключей.

Пусть на старте алгоритм затрагивает $k_{0}$ операций, а при сравнении $k_{1}$ операций. 

Пусть алгоритм нашёл элемент на первом сравнении (лучший случай), тогда будет затрачено $k_0 + k_1$ операций, на втором --- $k_0 + 2 \cdot k_1$, на последнем (худший случай) --- $k_0 + N \cdot k_1$. Если ключа нет в массиве ключей, то мы сможем понять это, только перебрав все ключи, таким образом трудоёмкость такого случая равно трудоёмкости случая с ключом на последней позиции. Трудоёмкость в среднем может быть рассчитана как математическое ожидание по формуле (\ref{for:brute}), где $\Omega$ -- множество всех возможных случаев.

\begin{equation}
\label{for:brute}
\begin{aligned}
\sum\limits_{i \in \Omega} p_i \cdot f_i = & (k_0 + k_1) \cdot \frac{1}{N + 1} + (k_0 + 2 \cdot k_1) \cdot \frac{1}{N+1} +\\& + (k_0 + 3 \cdot k_1) \cdot \frac{1}{N + 1} + (k_0 + Nk_1)\frac{1}{N + 1} + (k_0 + N \cdot k_1) \cdot \frac{1}{N + 1} =\\& = k_0\frac{N+1}{N+1}+k_1+\frac{1 + 2 + \cdots + N + N}{N + 1} = \\& = k_0 + k_1 \cdot \left(\frac{N}{N + 1} + \frac{N}{2}\right) = k_0 + k_1 \cdot \left(1 + \frac{N}{2} - \frac{1}{N + 1}\right)
\end{aligned}
\end{equation}

\section{Алгоритм поиска в упорядоченном словаре двоичным поиском}
Бинарный поиск базируется на том, что словарь изначально отсортирован, что позволяет сравнивать ключ с средним элементом, и, если, он меньше, то продолжать искать в левой части, таким же методом, иначе в правой.

Таким образом, при двоичном поиске \cite{binary} обход можно представить деревом, поэтому трудоёмкость в худшем случае составит $k_{0} + \log_2 N$ (в худшем случае нужно спуститься по двоичному дереву от корня до листа).

Лучшим случаем будет случай, если искомый ключ окажется средним элементом, тогда трудоемкость будет равна $k_{0} + \log_2 1$.

Скорость роста функции $\log_2 N$ меньше, чем скорость роста линейной функции, полученной для полного перебора.

\section{Вывод}
В данном разделе был рассмотрен абстрактный тип данных словарь и возможные реализации алгоритмов поиска в нём.

Программа будет получать на вход ключ, по кторому необходимо проивести поиск в словаре. При неверном вводе ключа (пустая строка) будет выведено сообщение об ошибке.

Реализуемое ПО дает возможность получить лог программы для двух алгоритмов (в лог файле содержится количество сравнения при поиске каждого ключа). Также имеется возможность построения графиков зависимотси времени поиска каждого ключа.